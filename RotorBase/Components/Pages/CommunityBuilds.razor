@page "/builds/gallery"
@rendermode InteractiveServer
@using System.Net.Http
@using System.Net.Http.Json
@using System.Text.Json
@using System.Text.Json.Serialization
@inject HttpClient Http
@inject NavigationManager Nav
@inject UserSession Session

<h1 class="sr-only">Community Builds</h1>

<div class="min-h-[calc(100vh-4rem)] bg-background text-foreground">
  <div aria-hidden="true" class="pointer-events-none absolute inset-x-0 top-0 h-32 bg-grid opacity-[.12]"></div>

  <section class="container py-6">
    <!-- Heading -->
    <div class="mb-3">
      <h2 class="text-2xl md:text-3xl font-bold tracking-tight">Community Builds</h2>
      <p class="text-sm text-foreground/70">Browse public builds shared by the community. View, clone, or jump straight to a buy plan.</p>
    </div>

    <!-- Filters -->
    <div class="card p-4 md:p-5 mb-5">
      <div class="grid grid-cols-1 gap-4 md:grid-cols-12 md:items-end">
        <div class="md:col-span-4">
          <label class="label">Search</label>
          <input class="input" placeholder="Search build names" @bind="SearchTerm" @bind:event="oninput" />
        </div>
        <div class="md:col-span-3">
          <label class="label">Engine code</label>
          <input class="input" placeholder="e.g., 13B-REW" @bind="EngineFilter" @bind:event="oninput" />
        </div>
        <div class="md:col-span-3">
          <label class="label">Sort</label>
          <select class="input" @bind="SortOption">
            <option value="recent">Recently updated</option>
            <option value="complete">Most complete</option>
            <option value="popular">Popular</option>
          </select>
        </div>
        <div class="md:col-span-2 flex gap-2">
          <button class="btn btn-primary w-full" @onclick="ApplyFiltersAsync" disabled="@IsLoading">Apply</button>
          <button class="btn btn-ghost w-full" @onclick="ResetFiltersAsync" disabled="@IsLoading">Reset</button>
        </div>
      </div>
    </div>

    <!-- Inline notices -->
    @if (!string.IsNullOrEmpty(CloneError))
    {
      <div class="card ring-1 ring-danger/25 bg-danger/5 text-danger px-4 py-2 mb-4" role="alert">@CloneError</div>
    }
    else if (!string.IsNullOrEmpty(CloneSuccess))
    {
      <div class="card ring-1 ring-success/25 bg-success/5 text-success px-4 py-2 mb-4" role="alert">@CloneSuccess</div>
    }

    <!-- States -->
    @if (IsLoading)
    {
      <div class="card px-4 py-3 mb-4 flex items-center gap-2 text-sm">
        <svg class="animate-spin h-4 w-4" viewBox="0 0 24 24">
          <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
          <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8v4A4 4 0 004 12z"></path>
        </svg>
        <span>Loading builds…</span>
      </div>
    }
    else if (!string.IsNullOrEmpty(ErrorMessage))
    {
      <div class="card ring-1 ring-danger/25 bg-danger/5 text-danger px-4 py-2" role="alert">@ErrorMessage</div>
    }
    else if (Items.Count == 0)
    {
      <div class="card px-4 py-3 text-sm text-foreground/70" role="alert">
        No builds found. Adjust filters or check back soon.
      </div>
    }
    else
    {
      <!-- Results grid -->
      <div class="grid grid-cols-1 gap-4 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4">
        @foreach (var item in Items)
        {
          <article class="card h-full p-4 flex flex-col">
            <header class="flex items-start justify-between gap-3">
              <div class="text-[11px] uppercase tracking-wide text-foreground/60">@item.EngineCode</div>
              <time class="text-xs text-foreground/50">@item.UpdatedAt.ToLocalTime().ToString("g")</time>
            </header>

            <h3 class="mt-1 line-clamp-2 text-base font-semibold">@item.Name</h3>

            <div class="mt-3">
              <div class="h-1.5 w-full rounded bg-muted">
                <div class="h-1.5 rounded bg-success transition-all" style="width:@GetCompletionPercent(item)%"></div>
              </div>
              <div class="mt-1 flex justify-between text-xs text-foreground/60 tabular-nums">
                <span>@FormatCompletion(item)</span>
                <span>@FormatCost(item)</span>
              </div>
            </div>

            <footer class="mt-auto pt-3">
              <div class="flex items-center gap-2">
                <button class="btn btn-soft h-8 px-3" @onclick="() => ViewBuild(item)">View</button>
                <button class="btn btn-ghost h-8 px-3" @onclick="() => BuyPlan(item)">Buy</button>

                <button class="ml-auto btn btn-primary h-8 px-3"
                        @onclick="() => CloneAsync(item)"
                        disabled="@Cloning.Contains(item.PublicSlug)">
                  @(Cloning.Contains(item.PublicSlug) ? "Cloning…" : "Clone")
                </button>
              </div>
            </footer>
          </article>
        }
      </div>

      @if (Total > PageSize)
      {
        <nav class="mt-5 flex items-center justify-between" aria-label="Pagination">
          <div class="text-xs text-foreground/60">Page @Page of @TotalPages</div>
          <div class="flex gap-2">
            <button class="btn btn-ghost h-8 px-3"
                    @onclick="PrevPageAsync" disabled="@(Page <= 1 || IsLoading)">
              Previous
            </button>
            <button class="btn btn-ghost h-8 px-3"
                    @onclick="NextPageAsync" disabled="@(!HasMore || IsLoading)">
              Next
            </button>
          </div>
        </nav>
      }
    }
  </section>
</div>

@code {
    class PublicBuildListResponse
    {
        [JsonPropertyName("items")] public List<PublicBuildListItem> Items { get; set; } = new();
        [JsonPropertyName("total")] public long Total { get; set; }
        [JsonPropertyName("page")] public int Page { get; set; }
        [JsonPropertyName("page_size")] public int PageSize { get; set; }
    }

    List<PublicBuildListItem> Items = new();
    bool IsLoading = true;
    string? ErrorMessage;
    string SearchTerm = string.Empty;
    string EngineFilter = string.Empty;
    string SortOption = "recent";
    int Page = 1;
    int PageSize = 12;
    long Total;
    string? CloneError;
    string? CloneSuccess;
    HashSet<string> Cloning = new(StringComparer.OrdinalIgnoreCase);

    int TotalPages => (int)Math.Ceiling((double)Total / PageSize);
    bool HasMore => Page * PageSize < Total;

    protected override async Task OnInitializedAsync()
    {
        await LoadAsync();
    }

    async Task ApplyFiltersAsync()
    {
        Page = 1;
        await LoadAsync();
    }

    async Task ResetFiltersAsync()
    {
        SearchTerm = string.Empty;
        EngineFilter = string.Empty;
        SortOption = "recent";
        Page = 1;
        await LoadAsync();
    }

    async Task PrevPageAsync()
    {
        if (Page > 1)
        {
            Page--;
            await LoadAsync();
        }
    }

    async Task NextPageAsync()
    {
        if (HasMore)
        {
            Page++;
            await LoadAsync();
        }
    }

    async Task LoadAsync()
    {
        IsLoading = true;
        ErrorMessage = null;
        CloneError = null;
        CloneSuccess = null;
        try
        {
            var url = $"/api/public/builds?sort={SortOption}&page={Page}&pageSize={PageSize}";
            if (!string.IsNullOrWhiteSpace(SearchTerm))
            {
                url += $"&q={Uri.EscapeDataString(SearchTerm)}";
            }
            if (!string.IsNullOrWhiteSpace(EngineFilter))
            {
                url += $"&engine={Uri.EscapeDataString(EngineFilter)}";
            }

            using var response = await Http.GetAsync(url);
            if (response.IsSuccessStatusCode)
            {
                var payload = await response.Content.ReadFromJsonAsync<PublicBuildListResponse>();
                Items = payload?.Items ?? new();
                Total = payload?.Total ?? Items.Count;
                Page = payload?.Page ?? Page;
                PageSize = payload?.PageSize ?? PageSize;
            }
            else
            {
                ErrorMessage = await ReadProblemAsync(response) ?? $"Load failed: {(int)response.StatusCode} {response.ReasonPhrase}";
            }
        }
        catch (Exception ex)
        {
            ErrorMessage = ex.Message;
        }
        finally
        {
            IsLoading = false;
            StateHasChanged();
        }
    }

    static async Task<string?> ReadProblemAsync(HttpResponseMessage response)
    {
        try
        {
            var content = await response.Content.ReadAsStringAsync();
            if (string.IsNullOrWhiteSpace(content)) return null;

            using var document = JsonDocument.Parse(content);
            var root = document.RootElement;
            if (root.ValueKind == JsonValueKind.Object)
            {
                if (root.TryGetProperty("detail", out var detailNode) && detailNode.ValueKind == JsonValueKind.String)
                {
                    var detail = detailNode.GetString();
                    if (!string.IsNullOrWhiteSpace(detail)) return detail;
                }

                if (root.TryGetProperty("title", out var titleNode) && titleNode.ValueKind == JsonValueKind.String)
                {
                    return titleNode.GetString();
                }
            }

            return content;
        }
        catch
        {
            return null;
        }
    }

    async Task CloneAsync(PublicBuildListItem item)
    {
        if (string.IsNullOrWhiteSpace(item.PublicSlug)) return;
        if (Cloning.Contains(item.PublicSlug)) return;

        CloneError = null;
        CloneSuccess = null;
        Cloning.Add(item.PublicSlug);
        StateHasChanged();

        try
        {
            var resp = await Http.PostAsJsonAsync($"/api/public/builds/{item.PublicSlug}/clone", new { });
            if (resp.IsSuccessStatusCode)
            {
                var doc = await resp.Content.ReadFromJsonAsync<JsonElement?>();
                if (doc is JsonElement el && el.TryGetProperty("build_id", out var idNode) && idNode.TryGetInt64(out var id))
                {
                    CloneSuccess = "Build cloned to your workspace.";
                    Nav.NavigateTo($"/builder/{id}");
                }
                else
                {
                    CloneSuccess = "Build cloned.";
                }
            }
            else if (resp.StatusCode == System.Net.HttpStatusCode.Unauthorized)
            {
                CloneError = "Sign in to clone builds.";
            }
            else
            {
                var detail = await resp.Content.ReadAsStringAsync();
                CloneError = $"Clone failed: {(int)resp.StatusCode} {resp.ReasonPhrase}. {detail}";
            }
        }
        catch (Exception ex)
        {
            CloneError = ex.Message;
        }
        finally
        {
            Cloning.Remove(item.PublicSlug);
            StateHasChanged();
        }
    }

    void ViewBuild(PublicBuildListItem item)
    {
        if (!string.IsNullOrWhiteSpace(item.PublicSlug))
        {
            Nav.NavigateTo($"/builds/public/{item.PublicSlug}");
        }
    }

    void BuyPlan(PublicBuildListItem item)
    {
        if (!string.IsNullOrWhiteSpace(item.PublicSlug))
        {
            Nav.NavigateTo($"/builds/public/{item.PublicSlug}#buy");
        }
    }

    int GetCompletionPercent(PublicBuildListItem item)
    {
        var pct = item.CompletionPct ?? 0m;
        pct = Math.Clamp(pct, 0m, 100m);
        return (int)Math.Round(pct);
    }

    string FormatCompletion(PublicBuildListItem item)
        => $"{(item.CompletionPct ?? 0m):0.0}%";

    string FormatCost(PublicBuildListItem item)
        => item.EstimatedCostLowest.HasValue ? item.EstimatedCostLowest.Value.ToString("C") : "—";
}
